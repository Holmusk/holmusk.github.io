<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Holmusk Tech Blog">
  <meta name="keywords" content="Haskell, Elm, Dart, Functional progarmming, FP">
  <meta name="author" content="Holmusk" />
  <title>Holmusk | Generating documentation from API types</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="../css/main.css">
  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg fixed-top" id="mainNav">
    <div class="container">
        <a class="navbar-brand" href="../index.html">
            <img src="../images/holmusk_product_blog.svg" alt="Holmusk Tech Blog">
        </a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          Menu
          <i class="fas fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="../index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../blog.html">Blog Posts</a>
            </li>
          </ul>
        </div>
    </div>
  </nav>

  <!-- Main Content -->
 <div class="container" id="page-content">
   <div class="row">
     <div class="container">
    <div class="row">
        <div class="col-lg-10 col-md-12 mx-auto">
            <h1 class="title">Generating documentation from API types</h1>
            <div class="post-context">
              <span class="date">May 18, 2020</span>
            </div>
            <div class="tag-list">
              
              <span><a class="tag" href="../tags/haskell.html">haskell</a></span>
              
            </div>
        </div>
    </div>

    <article>
      <div class="container">
        <div class="row">
          <div class="col-lg-10 col-md-12 mx-auto">
            <div class="toc"><ul>
<li><a href="#context">Context</a></li>
<li><a href="#requirements">Requirements</a><ul>
<li><a href="#supporting-various-output-formats">Supporting various output formats</a></li>
<li><a href="#including-format-types-in-our-documentation">Including format types in our documentation</a></li>
<li><a href="#automatically-generating-api-endpoints-documentation">Automatically generating API endpoints documentation</a></li>
</ul></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#overview">Overview</a></li>
</ul></li>
<li><a href="#parsing-the-api-type">Parsing the API type</a><ul>
<li><a href="#flattening-the-api-type">Flattening the API type</a></li>
<li><a href="#the-intermediate-structure">The intermediate structure</a></li>
<li><a href="#converting-the-api-type-to-a-value">Converting the API type to a value</a></li>
</ul></li>
<li><a href="#rendering-the-intermediate-structure">Rendering the intermediate structure</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#reflections">Reflections</a><ul>
<li><a href="#what-can-be-improved">What can be improved?</a></li>
<li><a href="#trade-offs">Trade offs</a></li>
<li><a href="#pros">Pros</a></li>
</ul></li>
<li><a href="#other-thoughts">Other thoughts</a></li>
</ul></div>
            <h2 id="context">Context</h2>
<p>As an Intern at Holmusk, I have been involved in projects which improve the quality of life for our programmers. The latest project I have worked on, servant-docs-simple allowed me to work with exciting things relating to type-level programming.</p>
<p>Our backend is currently built in Haskell, but those who need to use the APIs are Elm and Flutter developers. Hence, we should provide documentation of APIs which is readable by everyone.</p>
<p>Since our API uses <a href="https://hackage.haskell.org/package/servant"><span class="underline">Servant</span></a>, we attempted to use <a href="https://hackage.haskell.org/package/servant-docs"><span class="underline">servant-docs</span></a> to document our API. However, there were differing use cases so we created <a href="https://hackage.haskell.org/package/servant-docs-simple"><span class="underline">servant-docs-simple</span></a> to handle these.</p>
<h2 id="requirements">Requirements</h2>
<h3 id="supporting-various-output-formats">Supporting various output formats</h3>
<p>We want to output a variety of formats. Currently we support PlainText, JSON and PrettyPrint output formats.</p>
<p>These can be used in a variety of ways:</p>
<ul>
<li><p><code>JSON</code> can be served from an endpoint, allowing developers to query API endpoints and look up their documentation.</p></li>
<li><p><code>PlainText</code> documentation allows people to read through the whole documentation in PlainText.</p></li>
<li><p><code>PrettyPrint</code> allows people to further format text documentation to their liking.</p></li>
</ul>
<h3 id="including-format-types-in-our-documentation">Including format types in our documentation</h3>
<p>A <em>format type</em> is a Haskell data type. This type can be serialized to other forms, depending on instances which have been defined for it. For instance, if it has a JSON instance, it can be serialized to and from JSON.</p>
<p>Each endpoint accepts certain <em>format type(s)</em>. These format types are specified in the endpoint’s type definition, as part of its parameters. For instance, in its <code>RequestBody</code> parameter, we could say it accepts the CreateUser type and in the <code>Response</code> parameter we could say it returns the <code>UserData</code> type.</p>
<hr />
<p><em>Format type in documentation</em></p>
<pre><code>/api/user/
RequestType:
  Format: CreateUser
  ContentType: ...

Response:
  Format: UserData
  ContentType: ...</code></pre>
<hr />
<p>We can use these <em>format types</em> to search haskell source files to look up their type definitions. We can also look up our own generated files from these types. For example if a <code>users.proto</code> file is generated for the <code>UserData</code> type, we can search through that file to find the <code>protobuf</code> definition.</p>
<hr />
<p><em>Searching for the UserData type in users.proto</em></p>
<pre><code>message UserData {
    required string name = 1;
    ...
}

message UserCreate {
    ...
}

.
.
.
</code></pre>
<hr />
<p>In the documentation generated by servant-docs, the format types mentioned above <code>(User, Message)</code> are not included. They provide examples instead, which is a different usecase, since we want to use these <em>format types</em> to search our internal source files.</p>
<h3 id="automatically-generating-api-endpoints-documentation">Automatically generating API endpoints documentation</h3>
<p>servant-docs generates documentation only if <em>format types</em> have implemented the necessary instances. This is good for extensive documentation of the endpoints as users have to write examples for each <em>format type</em> they introduce.</p>
<hr />
<p><em>Instances for format types</em></p>
<pre><code>instance ToSample User where
    toSamples _ = &lt;some example&gt;

instance ToSample Message where
    toSamples _ = &lt;some example&gt;</code></pre>
<hr />
<p>However, in our case, we want to document our endpoints automatically, without having to write extra instances for each <em>format type</em> we introduce.</p>
<h2 id="implementation">Implementation</h2>
<p><em>Note: Some code snippets below are simplified for understanding. They may be approximations of the actual implementations.</em></p>
<h3 id="overview">Overview</h3>
<p>To allow us to parse to multiple output formats, we should:</p>
<ol type="1">
<li><p>Parse the api to an intermediate structure.</p></li>
<li><p>Render this structure to multiple output formats.</p></li>
</ol>
<h2 id="parsing-the-api-type">Parsing the API type</h2>
<h3 id="flattening-the-api-type">Flattening the API type</h3>
<p>We observe that the Servant API type is built by chaining together types. You can observe that <code>:&gt;</code> and <code>:&lt;|&gt;</code> serve as operators which introduce a tree-like structure to the API type.</p>
<p><code>:&gt;</code> extends the branch and <code>:&lt;|&gt;</code> forks multiple branches.</p>
<hr />
<p><em>Sample API type</em></p>
<pre><code>type API = Route :&gt; ( Request :&gt; Response
                 :&lt;|&gt; Route2 :&gt; Request2 :&gt; Response2
                    )
</code></pre>
<hr />
<p>Since a list is easier to parse than a tree, we can flatten this structure into a type-level list of endpoints. To do so, we use the Endpoints type family, applying it to the API type. For those unfamiliar with type families, you can think of them as functions which act on types.</p>
<hr />
<p><em>Flattened API type after applying the Endpoints type family</em></p>
<pre><code>Endpoints @API = '[ Route :&gt; Request :&gt; Response -- Endpt 1
                  , Route :&gt; Route2 :&gt; Request2 :&gt; Response2 -- Endpt 2
                  ]</code></pre>
<hr />
<p>The result is a type-level list of endpoints, which we can parse by pattern matching on <code>':</code> (for separating endpoints) and <code>:&gt;</code> (for separating parts of each endpoint). These operators <code>':</code> and <code>:&gt;</code> are similar to the cons operator <code>:</code> for lists, but on the type-level.</p>
<h3 id="the-intermediate-structure">The intermediate structure</h3>
<p>In the documentation, certain fields should come before others.</p>
<p>For example, the <code>route</code> of an endpoint should come before its <code>Request</code> or <code>Response</code> parameters. This allows users to easily find the route they need and access the relevant information for that route.</p>
<p>Hence structure we parse to should preserve the <strong>ordering</strong> of fields for each endpoint.</p>
<hr />
<p><em>When parsing each endpoint, we want this ordering</em></p>
<pre><code>Route: ...
Request: ...
Response: ...</code></pre>
<hr />
<p><em>Rather than this ordering</em></p>
<pre><code>Response: ...
Route: ...
Request: ...</code></pre>
<hr />
<p>Intuitively, the final structure should also permit us to use the route and its field names as keys, and their details as values. This is analogous to a <strong>JSON-like / map structure</strong> as shown below.</p>
<hr />
<p><em>“users/login”, “Response”, “Request”, “ContentType” are the keys below, bound by the (:) to their values.</em></p>
<pre><code>users/login/ : {
    Response: { ContentType: &lt;value&gt; }
    Request: { ... }
}</code></pre>
<hr />
<p>Hence, this is the Haskell type we want our API documentation to have. Notice the <a href="https://hackage.haskell.org/package/ordered-containers"><span class="underline">OMap</span></a> structure used. This gives us the 2 properties we need, <strong>ordered key-value pairs</strong> and a <strong>map structure</strong>.</p>
<hr />
<p><em>ApiDocs type</em></p>
<pre><code>import Data.Map.Ordered (OMap)

data ApiDocs = ApiDocs { unApiDocs :: OMap Route Details }
type Route = Text
data Details = Details (OMap Parameter Details) | Detail Text
type Parameter = Text</code></pre>
<hr />
<p><br></p>
<h3 id="converting-the-api-type-to-a-value">Converting the API type to a value</h3>
<p>How do we convert the <strong>API type</strong> to a <strong>value</strong> of type <code>ApiDocs</code>? Can we have a function which takes in types, returning values? Don’t functions primarily take in values?</p>
<p>To answer those questions, first, we recognize that our API type is built out of Servant types and type combinators.</p>
<hr />
<p><em>Examples of Servant types</em></p>
<pre><code>-- Type representing request body
data ReqBody (contentTypes :: [*]) (a :: *)

-- Type representing headers
data Header (sym :: Symbol) a</code></pre>
<hr />
<p><em>Example of Servant type combinator</em></p>
<pre><code>-- Type combinator (:&gt;) which combines Servant types
data (path :: k) :&gt; (a :: *)

-- Type combinator (:&gt;) is able to take in types as parameters
ReqBody '[()] () :&gt; Header &quot;&quot; ()</code></pre>
<hr />
<p>Then, using these combinators and types, we can build our API type.</p>
<hr />
<p><em>Our api with a single endpoint</em></p>
<pre><code>-- Here, using the (:&gt;) combinator,
-- we combine a type-level string &quot;users&quot;,
-- the ReqBody type and the Post type
type API = &quot;users&quot; :&gt; ReqBody '[()] () :&gt; Post '[()] ()</code></pre>
<hr />
<p>Inductively, if we can convert these types and type combinators to values, we can convert our <strong>API type</strong> to a <strong>value</strong>.</p>
<p>Now, we need to think of a way to pattern match on types to get values. The way would be <strong>typeclasses</strong>!</p>
<p>We can define different instances of a typeclass which match on different types. These instances can give us different values, so long as they conform to the definitions of that typeclass.</p>
<hr />
<p><em>Example of transforming types to values using typeclasses</em></p>
<pre><code>class HasAlphabet a where
    toAlpha :: String


data A

instance HasAlphabet A where
    toAlpha = &quot;A&quot;


data B

instance HasAlphabet B where
    toAlpha = &quot;B&quot;
    

-- Instantiating &quot;toAlpha&quot; for A and B

(toAlpha :: A) == &quot;A&quot;

(toAlpha :: B) == &quot;B&quot;</code></pre>
<hr />
<p>From this, we now know how to parse different servant types and type combinators. We can create a typeclass, define instances for all Servant types and type combinators, then use that to parse them.</p>
<p>With this knowledge, we can implement a typeclass that parses a single endpoint, since an endpoint is made up of servant types and combinators.</p>
<p>We match on the :&gt; combinator and other types, converting them to <code>Parameter-Detail</code> pairs and inserting them into the <code>Details OMap</code>. We then return a <code>Route-Detail</code> pair.</p>
<hr />
<p><em>Parsing each endpoint by pattern matching on :&gt;</em></p>
<pre><code>class HasParsable api where
    document :: Route -&gt; Details -&gt; (Route, Details)

-- Parses a route
instance HasSymbol p =&gt; HasParsable (p :&gt; a) where
    document r d = document @a $ r &lt;&gt; symbolVal (Proxy @p)
                               $ d


-- 'a' contains the rest of the API chain
instance HasParsable a =&gt; HasParsable (Auth :&gt; a) where
    document r d = document @a $ r
                               $ insert (&quot;Authentication&quot;, Detail &quot;true&quot;) d

instance ( HasParsable a
         , Typeable ct
         , Typeable typ
         ) =&gt; HasParsable (ReqBody ct typ :&gt; a) where

    document r d = document @a $ r
                               $ insert ( &quot;Request&quot;
                                        , Details ( insert ( &quot;Content-type&quot;
                                                           , typeRep @ct
                                                           )
                                                  . insert ( &quot;Format&quot;
                                                           , typeRep @typ
                                                           )
                                                  $ empty
                                                  )
                                        ) d</code></pre>
<p>We can convert types into their text form by using <code>typeRep</code> from <a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Typeable.html"><span class="underline">Data.Typeable</span></a> and type-level strings into their string equivalent by using <code>symbolVal</code> from <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-TypeLits.html"><span class="underline">GHC.TypeLits</span></a>.</p>
<p>Next, we have a typeclass that destructures the flattened API type. As mentioned earlier, the flattened API type is a type-level list of endpoints. The typeclass recurses through the list, converting each Endpoint type into a <code>Route-Details</code> pair.</p>
<p>Since each endpoint type is an instance of the <code>HasParsable</code> typeclass, we can use the document function for the conversion. We then insert the pair into the rest of the <code>ApiDocs OMap</code>.</p>
<hr />
<p><em>Collating the ApiDocs by pattern matching on ':</em></p>
<pre><code>class HasCollatable api where
    collate :: ApiDocs

instance HasCollatable (endpoint ': b) where
    collate = document endpoint `insert` unApiDocs (collate @b)

instance HasCollatable '[] where
    collate = ApiDocs empty -- An empty OMap</code></pre>
<hr />
<p><br></p>
<h2 id="rendering-the-intermediate-structure">Rendering the intermediate structure</h2>
<p>The ApiDocs structure can then be rendered into other formats using another typeclass.</p>
<hr />
<p><em>Renderable typeclass</em></p>
<pre><code>class Renderable a where
    render :: ApiDocs -&gt; a -- Render to specified format types

instance Renderable JSON
...

instance Renderable PlainText
...</code></pre>
<hr />
<h2 id="usage">Usage</h2>
<p>Now, to get the documentation we can parse the API and then render it to the desired format.</p>
<hr />
<p><em>Writing the docs as PlainText to a file</em></p>
<pre><code>type MyAPI = ...

main :: IO ()
main = writeToFile apiDocs

writeToFile :: PlainText -&gt; IO ()
writeToFile = ...

apiDocs :: PlainText
apiDocs = render @PlainText (parse @MyAPI)</code></pre>
<hr />
<h2 id="reflections">Reflections</h2>
<h3 id="what-can-be-improved">What can be improved?</h3>
<p>Currently there are some <a href="https://github.com/Holmusk/servant-docs-simple/issues"><span class="underline">issues</span></a> opened in the repository.</p>
<p>The main ones which come to mind would be:</p>
<ul>
<li><p><a href="https://github.com/Holmusk/servant-docs-simple/issues/8"><span class="underline">Pretty printing some of the typeRep output</span></a></p></li>
<li><p><a href="https://github.com/Holmusk/servant-docs-simple/issues/6"><span class="underline">Implementing support for all modifiers</span></a></p></li>
</ul>
<h3 id="trade-offs">Trade offs</h3>
<p>Documentation may not be sufficiently extensive, as the generated documentation lacks examples by default. These are up to the user to include.</p>
<p>Servant-docs has a much more developed ecosystem. These can be seen through packages such as servant-pandoc which supports many more output formats than servant-docs-simple.</p>
<h3 id="pros">Pros</h3>
<p>You get lightweight documentation for free! As long as you have an Api type, you can generate simple documentation in a variety of outputs.</p>
<p>It is also easy to extend. We have included a bunch of <a href="https://github.com/Holmusk/servant-docs-simple#tutorials"><span class="underline">tutorial</span></a> scripts you can refer to. These include writing your own <a href="https://github.com/Holmusk/servant-docs-simple/blob/master/examples/render.hs"><span class="underline">Renderable instances for rendering custom output</span></a> and <a href="https://github.com/Holmusk/servant-docs-simple/blob/master/examples/custom.hs"><span class="underline">HasParsable instances to parse custom types</span></a>.</p>
<h2 id="other-thoughts">Other thoughts</h2>
<p>Writing this library was very interesting, as it was the first time I tried type-level programming. It was a similar feeling as when I first learnt about Monoids, Functors and Monads.</p>
<p>When I started working on this project I was worried but excited. After having heard interesting things about Servant, but never really understanding it, I could finally get some experience. Along the way I referenced <a href="https://docs.servant.dev/en/stable/"><strong><span class="underline">Servant's documentation</span></strong></a> and <a href="https://thinkingwithtypes.com/"><strong><span class="underline">Thinking with Types</span></strong></a> which have helped me immensely to understand type-level programming in Haskell.</p>
<p>After working on this project, I understand compile-time safety a lot better . By encoding the API as a type, we can more safely reuse it in a variety of ways, such as documentation (as in this case), on the client-side and so on.</p>
<p>I also learned about the nitty-gritty bits of packaging a module, like how to upload to Hackage, Stackage, configure the CI, setting up the project with <a href="https://github.com/kowainik/summoner"><span class="underline">summoner</span></a>, among many other things.</p>
<p>For more details, you can reference the <a href="https://github.com/Holmusk/servant-docs-simple"><strong><span class="underline">README</span></strong></a> as well as the <a href="https://hackage.haskell.org/package/servant-docs-simple"><strong><span class="underline">Hackage</span></strong></a> docs. We also welcome PRs and Issues to improve the package! Thanks for reading :)</p>
          </div>
        </div>
      </div>
    </article>

</div>

   </div>
 </div>

 <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-10 col-md-12 mx-auto">
        <p class="copyright text-muted">©2019 Holmusk</p>
      </div>
    </div>
  </div>
</footer>


</body>
</html>
